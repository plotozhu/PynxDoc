# 概述

组播功能通过ｂｅｈａｖｉｏｒ的Ｄｉｓｃｏｖｅｒｙ模块，向

## 数据处理

由于组内的节点是无向和平等的，组播会产生重复传输问题：有节点Ａ／Ｂ和Ｃ，都同属于一个组Ｍ，那么：
Ａ发送数据包Ｐ给Ｂ/Ｃ后,Ｂ／Ｃ节点收到此数据，进行发处理后，发现需要继续传播，因此发送给邻节点，Ａ是他们的邻节点，因此他们会再次把数据发给Ａ。这种情况下，既浪费了网络带宽，又使Ａ可能会重复处理数据，因此需要做处理。

### 处理方案１－－来源记录
来源记录是一种比较简单的处理方式，将Ｂ收到Ａ的数据包时，记录该数据包的来源是Ａ，再次传播时，跳过Ａ这个节点。　　
这是一种粗暴的处理方式，并不能完全解决问题，假设Ａ与Ｂ连接，Ｂ与Ｃ连接，Ａ/Ｃ与Ｄ连接，那么Ａ发送的数据包，经过ＢＣ中继后到达Ｄ，而Ｄ并不清楚这个数据包其实来源于Ａ，有可能还是会发送给Ａ。这种情况常发生于Ｄ与Ａ刚刚建立连接的时候。

### 处理方案２－－推拉
数据包首先产生一个唯一的哈希，当Ａ需向邻节点发送某个数据包时，先向邻节点“推送”该数据包的哈希值，对端节点收到该数据的哈希值后，检查该数据是否在本地已经存在，如果不存在，就向来源节点请求“拉取”此数据。如果已经存在，就忽略此数据推送请求。

### 处理方案３　--推拉＋来源记录
１）　综合上述的１和２，收到“推送”过来的哈希时，记录该数据的哈希和来源节点，我们称这些节点已经“知道”了这个数据；
２）　当需要传播时，只推送给不“知道”这个数据的节点。

### 补充处理　－－ＴＴＬ

由于记录数据的哈希和来源节点的列表数量有限，一般是一个ＬＲＵ列表，因此过一段时间后，就会“忘了”某个节点已经“知道”某个数据包，这种情况可能会导致某个数据包一直在网络中传播。为了解决这个问题，每个数据包都有一个ＴＴＬ，每传播一次，该ＴＴＬ就减１，如果ＴＴＬ为０，就不再传播。

## 数据缓存

当请求发送到某个组时，该组内的节点可能还没有建立连接完成，因此需要建立一个数组缓存，将待发送的数据缓存，当节点连接成功时，将缓存的数据发送出去。
缓存的数据可以指定需要缓存的时间，超时后数据将自动被丢弃,因此数据发送可能返回三种状态：已经发送、失败或是已经缓存。或者我们也可以考虑使用ｆｕｔｕｒｅ来返回？

# 组播功能说明
## 注册组
### 功能说明
通过此功能，上层应用向组播模块注册自身所属于的组，组的名称是８字节的一个数组
注意一个应用可能属于多个组，目前一个应用可能最多会属于４０个组
### 服务处理
组播服务接收到此命令后，
１)　如果已经加入，则忽略此请求，否则：
２）　在已经加入的组列表中添加新组
３)　在网络加入组，与其他加入该组的节点建立连接
### 接口定义

## 退出组
### 功能说明　
通过此功能，上层应用通知组播模块自身需要退出某个组了，组的名称是一个８字节的数组
### 服务处理
组播服务收到此命令后
１)　如果不在对应的组中，则忽略此请求，否则:
２)　断开与此组中节点的连接
３)　在已经加的组列表中删除此组
## 查询自身所属于的组
### 功能说明
此功能查询当前节点已经加入的组的数组

## 查询连接到某个组的节点
### 功能说明
此功能查询当前节点已经连接到的某个组的所有节点ＩＤ信息

### 服务处理

组播服务收到此命令后：
１) 如果没有加入所查询的组，返回错误：尚未加入此组，否则：
２）返回已经连接的与此组的节点

## 请求发送
### 功能说明
请求发送数据到某个组，这是基本的数据过程
### 服务处理
组播服务收到此命令后，
１)　如果自身没有加入目标组，返回错误，否则：
２）　缓存此数据及对应的哈希，
３）　传播给该组内的所有节点

## 数据到达
数据到达时，通过Ｐｒｏｔｏｃｏｌ层进行处理，与原有的处理方式一致
